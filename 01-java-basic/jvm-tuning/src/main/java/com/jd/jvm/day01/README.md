# JVM内存开销详解

## 问题：为什么分配10MB就OOM，而最大内存是24MB？

### 一、Java对象的内存布局

每个Java对象在内存中的实际占用 > 声明的大小：

```
┌─────────────────────────────────────────┐
│  Java对象内存布局（以byte[1MB]为例）      │
├─────────────────────────────────────────┤
│  1. 对象头 (Object Header)               │
│     - Mark Word: 8 bytes                │
│     - Class Pointer: 4-8 bytes          │
│     - 数组长度: 4 bytes                  │
│     小计: ~16-20 bytes                   │
├─────────────────────────────────────────┤
│  2. 数组数据                             │
│     - byte[1024*1024]: 1,048,576 bytes  │
├─────────────────────────────────────────┤
│  3. 对齐填充 (Padding)                   │
│     - 0-7 bytes                         │
│     (总大小必须是8的倍数)                 │
└─────────────────────────────────────────┘
总计: ~1,048,596 bytes ≈ 1.000019 MB
```

### 二、24MB堆内存的实际使用情况

```
┌────────────────────────────────────────────────┐
│           堆内存 24MB (-Xmx24m)                 │
├────────────────────────────────────────────────┤
│  1. JVM启动占用 (~2-3MB)                        │
│     • java.lang.System                        │
│     • java.lang.String 常量池                  │
│     • 类加载器数据                              │
│     • 基础类库对象                              │
├────────────────────────────────────────────────┤
│  2. GC管理开销 (~1-2MB)                         │
│     • Eden区、Survivor区的管理结构             │
│     • Old Gen的管理结构                        │
│     • GC算法需要的辅助空间                      │
├────────────────────────────────────────────────┤
│  3. ArrayList容器开销 (~0.5MB)                  │
│     • ArrayList对象本身                        │
│     • 内部Object[]数组（会动态扩容）            │
│     • 每个byte[]引用 (8 bytes × N个)           │
├────────────────────────────────────────────────┤
│  4. 对象头开销                                  │
│     • 每个1MB数组 ~20 bytes对象头              │
│     • 10个数组 = ~200 bytes                    │
├────────────────────────────────────────────────┤
│  5. GC预留空间 (~8-10MB)                        │
│     • Young GC需要Survivor空间                │
│     • Full GC需要预留空间                      │
│     • 防止频繁GC的缓冲区                       │
├────────────────────────────────────────────────┤
│  6. 实际可用于byte[]数据 (~10-12MB)             │
│     ✓ 这就是为什么只能分配10MB左右！            │
└────────────────────────────────────────────────┘
```

###三、详细计算示例

假设成功分配了10个 `byte[1024*1024]` 数组：

| 项目 | 大小 | 说明 |
|------|------|------|
| JVM启动占用 | ~3 MB | System、String池等 |
| GC元数据 | ~1.5 MB | 垃圾回收管理结构 |
| ArrayList开销 | ~0.5 MB | 容器对象+引用数组 |
| 10个对象头 | ~0.0002 MB | 20字节×10 |
| GC预留空间 | ~8 MB | Survivor等 |
| **实际数据** | **10 MB** | **10个1MB数组** |
| **总计** | **~23 MB** | **≈ 24MB** |

### 四、验证方法

运行 `MemoryOverheadDemo.java` 可以看到详细的内存分配过程：

```bash
# 编译
javac -encoding UTF-8 com/jd/jvm/day01/MemoryOverheadDemo.java

# 运行（设置24MB堆内存）
java -Xmx24m -Xms24m -XX:+PrintGCDetails com.jd.jvm.day01.MemoryOverheadDemo
```

### 五、关键知识点

#### 1. **对象开销不可忽略**
即使是简单的 `byte[]`，也有20字节左右的对象头。

#### 2. **容器有额外开销**
ArrayList、HashMap等容器本身也需要内存。

#### 3. **GC需要工作空间**
垃圾回收器需要预留空间来移动对象（特别是复制算法）。

#### 4. **-Xmx不是全部可用**
`-Xmx` 设置的是**堆的最大值**，但实际可用于应用数据的空间要小得多。

#### 5. **内存碎片**
频繁分配和回收会产生内存碎片，降低内存使用效率。

### 六、实战建议

#### 1. **合理设置堆大小**
```bash
# 生产环境建议
-Xms4g -Xmx4g  # 初始和最大设置相同，避免动态扩容
```

#### 2. **监控实际内存使用**
```java
Runtime runtime = Runtime.getRuntime();
long usedMemory = runtime.totalMemory() - runtime.freeMemory();
System.out.println("实际使用: " + (usedMemory / 1024 / 1024) + "MB");
```

#### 3. **注意对象创建**
```java
// 不好: 频繁创建大对象
for (int i = 0; i < 1000; i++) {
    byte[] temp = new byte[1024 * 1024]; // 每次1MB
}

// 好: 复用对象
byte[] buffer = new byte[1024 * 1024]; // 只创建一次
for (int i = 0; i < 1000; i++) {
    // 复用buffer
}
```

#### 4. **使用工具分析**
- VisualVM：可视化监控内存使用
- JProfiler：专业性能分析
- MAT：内存泄漏分析

### 七、常见误区

❌ **误区1**：-Xmx24m就能存24MB数据
✅ **正确**：实际可用空间远小于24MB

❌ **误区2**：byte[1MB]占用正好1MB
✅ **正确**：还有对象头、对齐等开销

❌ **误区3**：GC会释放所有空间
✅ **正确**：GC需要预留工作空间

### 八、总结

**为什么10MB就OOM？**

1. **对象头开销**：每个数组额外20字节
2. **容器开销**：ArrayList及其内部结构
3. **JVM启动开销**：基础类库、System等
4. **GC管理开销**：垃圾回收器的元数据
5. **GC预留空间**：Survivor区等需要预留
6. **内存碎片**：分配过程中的碎片

**最终结果**：24MB - 各种开销 ≈ 10-12MB 实际可用空间

这就是为什么你看到"已分配10MB"就OOM了！
